###########################################################################
# CLUSTERER FARM
# here we nuture young clusterers to maturity
# included clustering methods that can be used with mapper
###########################################################################

# hierarchical clustering -------------------------------------------------

#' Perform agglomerative clustering on a single distance matrix.
#'
#' @param dist A distance matrix.
#' @param method A string to pass to [hclust] to determine clustering method.
#'
#' @return A dendrogram generated by `fastcluster`.
get_agglomerative_dendrogram <- function(dist, method) {
  if (!(inherits(dist, "dist")) & (any(is.na(dist)))) {
    return(vector())
  } else if (!(inherits(dist, "dist"))) {
    res = list(1)
    names(res) = dist
    return(res)
  } else {
    return(fastcluster::hclust(dist, method))
  }
}

#' Cut a single dendrogram
#'
#' @param dend A dendrogram to be cut.
#' @param cut_height A height at which to cut the dendrogram.
#' @return A cluster assignment resulting from `cutree`. It is a named vector whose names are data point names and whose values are cluster labels.
cut_dendrogram <- function(dend, cut_height) {
  return(cutree(dend, h = cut_height))
}

#' Cut many dendrograms
#'
#' @param dends A list of dendrograms to be cut.
#' @param cut_heights A list of cut heights which corresponds to each dendrogram in `dends`.
#' @return A list of named vectors (one per dendrogram) whose names are data point names and whose values are cluster labels.
process_dendrograms <- function(dends, cut_heights) {
  # in case we get a single dendrogram and not a list of them
  if (inherits(dends, "hclust")) {
    return(cut_dendrogram(dends, cut_heights))
  }

  snipped_dends = mapply(cut_dendrogram,
                         dends,
                         cut_heights,
                         SIMPLIFY = FALSE)
  print("cut all the dendrograms...")
  return(snipped_dends)
}

#' Find the tallest branch of a dendrogram
#'
#' @param dend A single dendrogram.
#' @param max_height The maximum height of the dendrogram; if this is not provided the last merge height of the input dendrogram will be used, which will make one cluster impossible!
#'
#' @return The height of the tallest branch (longest time between merge heights) of the input dendrogram.
get_tallest_branch_height <- function(dend, max_height = max(cophenetic(dend))) {
  # TODO remove all the duplicate code lol
  heights = append(sort(unique(cophenetic(dend))), max_height) # merge heights of dendrogram

  branch_lengths = diff(heights) # differences are branch lengths

  tallest_branch_height = max(branch_lengths)
  tallest_branch_id = which(branch_lengths == tallest_branch_height)
  cutval = (heights[tallest_branch_id] + heights[tallest_branch_id + 1]) / 2 # midpoint of tallest branch

  if (length(cutval) > 1) {
    cutval = sample(cutval, 1)
  }
  
  return(cutval)
}

#' Perform single-linkage hierarchical clustering and process dendrograms.
#'
#' @param dist_mats A list of distance matrices to be used for clustering.
#' @param method A string to pass to [hclust] to tell it what kind of clustering to do.
#' @param cut_height A global cut height, if you would like to specify one.
#'
#' @return A list containing named vectors (one per dendrogram), whose names are data point names and whose values are cluster labels.
get_hierarchical_clusters <- function(dist_mats, method, cut_height = -1) {
  # do agglomerative clustering on distance matrices
  dends = lapply(dist_mats, get_agglomerative_dendrogram, method)

  max_dists = sapply(dist_mats, max)
  nonzero_max_dists = max_dists[max_dists != 0]

  # we would like to cut non-trivial dendrograms to determine number of clusters
  real_dends = dends[lapply(dends, length) > 1]
  imposter_dends = dends[lapply(dends, length) == 1]

  if (cut_height == -1) {
    cut_heights = mapply(get_tallest_branch_height, real_dends, max_dists)
  } else {
    cut_heights = rep(cut_height, length(max_dists))
  }

  # cut nontrival dendrograms and get clusters
  processed_dends = process_dendrograms(real_dends, cut_heights)

  # combine nontrival and trivial clusterings and return results
  if (length(imposter_dends) != 0) {
    return(append(processed_dends, sapply(imposter_dends, function(x)
      list(unlist(x))))) # LMAO what is this
  } else {
    return(processed_dends)
  }
}

#' Create a dude to perform hierarchical clustering in a global context using the [hclust] package.
#'
#' @param method A string to pass to [hclust] to tell it what kind of clustering to do.
#' @param dists The global distance matrix to run clustering on to determine a global cutting height.
#'
#' @returns A function that inputs a list of distance matrices and returns a list containing one vector per bin, whose element names are data point names and whose values are cluster labels (within each bin).
#' @details This clusterer determines cutting heights for bin dendrograms generated by [hclust] by cutting them all according to the best global cutting height when the data is clustered together.
#' @export
#'
#' @examples
#' data = data.frame(x = sapply(1:100, function(x) cos(x)), y = sapply(1:100, function(x) sin(x)))
#' projx = data$x
#' 
#' dists = dist(data)
#'
#' num_bins = 10
#' percent_overlap = 25
#'
#' cover = create_width_balanced_cover(min(projx), max(projx), num_bins, percent_overlap)
#'
#' create_1D_mapper_object(data, dists, projx, cover, global_hierarchical_clusterer("mcquitty", dists))
global_hierarchical_clusterer <- function(method, dists) {
  global_linkage = get_agglomerative_dendrogram(as.dist(dists), method)
  max_dist = max(dists)
  cut_height = get_tallest_branch_height(global_linkage, max_dist)
  return(function(dist_mats) get_hierarchical_clusters(dist_mats, method, cut_height = cut_height))
}

#' Create a dude to perform hierarchical clustering in a local context using the [hclust] package.
#'
#' @param method A string to pass to [hclust] to tell it what kind of clustering to do.
#'
#' @returns A function that inputs a list of distance matrices and returns a list containing one vector per bin, whose element names are data point names and whose values are cluster labels (within each bin).
#' @details This clusterer determines cutting heights for patch dendrograms generated by [hclust] by cutting them at their respectively longest branches, ignoring global context.
#' @export
#'
#' @examples
#' data = data.frame(x = sapply(1:100, function(x) cos(x)), y = sapply(1:100, function(x) sin(x)))
#' projx = data$x
#' 
#' dists = dist(data)
#'
#' num_bins = 10
#' percent_overlap = 25
#'
#' cover = create_width_balanced_cover(min(projx), max(projx), num_bins, percent_overlap)
#'
#' create_1D_mapper_object(data, dists, projx, cover, local_hierarchical_clusterer("mcquitty"))
local_hierarchical_clusterer <- function(method) {
  return(function(dist_mats) get_hierarchical_clusters(dist_mats, method))
}
